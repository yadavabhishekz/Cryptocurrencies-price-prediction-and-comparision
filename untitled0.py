# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RXBY8trvoi1aAmaiY5cqKRuVgzqPzbBp
"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
plt.style.use('fivethirtyeight')

# Define the cryptocurrencies to analyze
CRYPTO_LIST = ['BTC-USD', 'ETH-USD', 'BNB-USD', 'SOL-USD', 'XRP-USD',
               'ADA-USD', 'DOGE-USD', 'DOT-USD', 'SHIB-USD', 'AVAX-USD']

# Function to fetch data for multiple cryptos
def get_crypto_data(crypto_list, years=10):
    end = datetime.now()
    start = datetime(end.year - years, end.month, end.day)

    crypto_data = {}
    for crypto in crypto_list:
        data = yf.download(crypto, start=start, end=end)
        if not data.empty:
            crypto_data[crypto] = data
    return crypto_data

print("Downloading data...")
crypto_data = get_crypto_data(CRYPTO_LIST)
print(f"Downloaded {len(crypto_data)} cryptocurrencies")

# Display sample data for BTC-USD
crypto_data['BTC-USD'].head()

!pip install ta

crypto_data['BTC-USD'].columns

# 1. First ensure proper column names in your data
for crypto in crypto_data:
    if isinstance(crypto_data[crypto].columns, pd.MultiIndex):
        crypto_data[crypto].columns = crypto_data[crypto].columns.droplevel(1)

# 2. Verify the columns look correct
print(crypto_data['BTC-USD'].head(2))

# 3. Now add technical indicators
from ta import add_all_ta_features

for crypto in crypto_data:
    try:
        crypto_data[crypto] = add_all_ta_features(
            crypto_data[crypto],
            open="Open", high="High", low="Low",
            close="Close", volume="Volume",
            fillna=True
        )
        print(f"Successfully added indicators for {crypto}")
    except Exception as e:
        print(f"Failed for {crypto}: {str(e)}")
        # Drop problematic cryptos
        crypto_data.pop(crypto, None)

# 4. Check the results
print(crypto_data['BTC-USD'].columns.tolist()[:20])  # Show first 20 columns

# Keep only cryptos with successful feature addition
CRYPTO_LIST = list(crypto_data.keys())

from sklearn.preprocessing import MinMaxScaler


# Prepare dataset for multiple cryptocurrencies
def prepare_multi_crypto_dataset(crypto_data, window_size=100):
    X, y = [], []
    scaler = MinMaxScaler(feature_range=(0, 1))

    for crypto, data in crypto_data.items():
        # Use Close price and 5 key technical indicators
        features = data[['Close', 'volume_adi', 'volatility_bbm', 'trend_macd', 'momentum_rsi', 'trend_ema_fast']]
        scaled_data = scaler.fit_transform(features)

        # Create sequences
        for i in range(window_size, len(scaled_data)):
            X.append(scaled_data[i-window_size:i])
            y.append(scaled_data[i, 0])  # Only predict Close price

    return np.array(X), np.array(y), scaler

X, y, scaler = prepare_multi_crypto_dataset(crypto_data)
print(f"Total samples: {len(X)} from {len(crypto_data)} cryptocurrencies")

from keras.models import Sequential
from keras.layers import LSTM, Dense, Dropout, Bidirectional

model = Sequential([
    Bidirectional(LSTM(256, return_sequences=True)),
    Dropout(0.3),
    LSTM(128),
    Dropout(0.2),
    Dense(64, activation='relu'),
    Dense(1)
])

model.compile(optimizer='adam', loss='mse')

# Train-test split
split_idx = int(0.9 * len(X))
X_train, X_test = X[:split_idx], X[split_idx:]
y_train, y_test = y[:split_idx], y[split_idx:]

print(f"Input shape - X_train: {X_train.shape}, y_train: {y_train.shape}")
print(f"Input shape - X_test: {X_test.shape}, y_test: {y_test.shape}")

from keras.callbacks import EarlyStopping

# Define EarlyStopping callback
early_stop = EarlyStopping(
    monitor='val_loss',
    patience=3,
    restore_best_weights=True,
    verbose=1
)


print("\nTraining model...")
history = model.fit(
    X_train, y_train,
    validation_data=(X_test, y_test),
    batch_size=32,
    epochs=20,
    callbacks=[early_stop],
    verbose=1
)

# Plot training history
plt.figure(figsize=(10, 6))
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Training History')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend()
plt.grid(alpha=0.3)
plt.show()

# 1. Save the entire model (recommended)
model.save("crypto_lstm_final.keras")  # .keras is the new recommended format

# 2. Save weights (use the exact required extension)
model.save_weights("crypto_lstm.weights.h5")  # Note the .weights.h5 extension

# 3. Save the scaler
import joblib
joblib.dump(scaler, "crypto_scaler.pkl")

# 4. Save feature list (for reference)
import json
with open("feature_columns.json", "w") as f:
    json.dump({
        "features_used": ['Close'],  # Update if using more features
        "window_size": 100,
        "cryptos_supported": CRYPTO_LIST
    }, f)

print("All model assets saved successfully!")

import numpy as np
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import joblib

def safe_inverse_transform(scaler, data, feature_index=0):
    """
    Safely inverse transforms single feature when scaler was fit on multiple features

    Parameters:
        scaler: The fitted scaler object
        data: 1D array of values to inverse transform
        feature_index: Which feature position this data represents in original scaler

    Returns:
        1D array of inverse transformed values
    """
    dummy = np.zeros((len(data), scaler.n_features_in_))
    dummy[:, feature_index] = data.flatten()
    return scaler.inverse_transform(dummy)[:, feature_index]

def evaluate_model(model, X_test, y_test, scaler):
    """
    Evaluate model performance with proper inverse scaling

    Parameters:
        model: Trained Keras model
        X_test: Test features
        y_test: Test targets
        scaler: Scaler used for original feature scaling

    Returns:
        y_test_orig: Inverse transformed actual values
        y_pred_orig: Inverse transformed predicted values
    """
    # Generate predictions
    y_pred = model.predict(X_test, verbose=0)

    # Inverse transform using safe method
    y_test_orig = safe_inverse_transform(scaler, y_test)
    y_pred_orig = safe_inverse_transform(scaler, y_pred)

    # Calculate metrics
    mae = mean_absolute_error(y_test_orig, y_pred_orig)
    rmse = np.sqrt(mean_squared_error(y_test_orig, y_pred_orig))

    print(f"Test Set Evaluation Results:")
    print(f"MAE: ${mae:.2f}")
    print(f"RMSE: ${rmse:.2f}")

    # Plot results
    plt.figure(figsize=(12, 6))
    plt.plot(y_test_orig, label='Actual Prices', color='blue')
    plt.plot(y_pred_orig, label='Predicted Prices', color='red', alpha=0.7)
    plt.title("Actual vs Predicted Prices (Test Set)")
    plt.ylabel("Price (USD)")
    plt.xlabel("Test Samples")
    plt.legend()
    plt.grid(alpha=0.3)
    plt.show()

    return y_test_orig, y_pred_orig

# Now run the evaluation
print("Evaluating model performance...")
y_test_orig, y_pred_orig = evaluate_model(model, X_test, y_test, scaler)

# Save the evaluation results for future reference
np.save("y_test_orig.npy", y_test_orig)
np.save("y_pred_orig.npy", y_pred_orig)
print("Evaluation complete. Results saved.")

## **7. Prediction Functions**
def predict_future(model, scaler, crypto_data, crypto, days=10):
    if crypto not in crypto_data:
        raise ValueError(f"No data for {crypto}")

    last_100 = crypto_data[crypto][['Close', 'volume_adi', 'volatility_bbm',
                                  'trend_macd', 'momentum_rsi', 'trend_ema_fast']].tail(100)
    scaled_data = scaler.transform(last_100)

    predictions = []
    current_seq = scaled_data.reshape(1, 100, 6)

    for _ in range(days):
        next_pred = model.predict(current_seq, verbose=0)
        predictions.append(next_pred[0,0])

        # Update sequence
        new_row = np.zeros((1, 1, 6))
        new_row[0,0,0] = next_pred
        current_seq = np.append(current_seq[:,1:,:], new_row, axis=1)

    # Inverse transform
    dummy = np.zeros((len(predictions), 6))
    dummy[:,0] = predictions
    return scaler.inverse_transform(dummy)[:,0]

future_predictions = predict_future(model, scaler, crypto_data, "BTC-USD")
print("\nBTC-USD next 10 days prediction:")
print(future_predictions)

plt.figure(figsize=(12, 6))
plt.plot(range(1, 11), future_predictions, marker='o', color='purple')
plt.title("Next 10 Days Price Prediction")
plt.xlabel("Days from Now")
plt.ylabel("Predicted Price (USD)")
plt.grid(alpha=0.3)
for i, price in enumerate(future_predictions):
    plt.text(i+1, price, f"${price:.2f}", ha='center', va='bottom')
plt.show()

## **8. Comparison Visualization**
def plot_crypto_comparison(model, scaler, crypto_data, cryptos, days=10):
    plt.figure(figsize=(14, 7))

    for crypto in cryptos:
        if crypto in crypto_data:
            preds = predict_future(model, scaler, crypto_data, crypto, days)
            plt.plot(range(1, days+1), preds, marker='o', label=crypto)

    plt.title(f'Price Predictions (Next {days} Days)')
    plt.xlabel('Days Ahead')
    plt.ylabel('Price (USD)')
    plt.legend()
    plt.grid(alpha=0.3)
    plt.show()

# Compare top 3 cryptos
plot_crypto_comparison(model, scaler, crypto_data, ['BTC-USD', 'ETH-USD', 'BNB-USD'])

